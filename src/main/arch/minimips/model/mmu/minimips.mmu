/*
 * Copyright 2015 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

extern E1 = GPR[1]
extern E2 = REG(2)
let C1 = E1 + E2
let C2 = E1 + 1

//==================================================================================================
// Virtual Address (VA)
//==================================================================================================

address VA(value: 32)

//==================================================================================================
// Physical Address (PA)
//==================================================================================================

address PA(value: 32)

//==================================================================================================
// Segments
//==================================================================================================

segment SEG (va: VA) = (pa : PA)
  range = (0x00000000, 0xffffffff)

//==================================================================================================
// Cache Memory (L1 and L2)
//==================================================================================================

buffer L1 (pa: PA)
  ways   = 4
  sets   = 128
  entry  = (V: 1 = 0, TAG: 20, DATA: 256)
  index  = pa.value<11..5>
  match  = V == 1 && TAG == pa.value<31..12>
  policy = PLRU

buffer L2 (pa: PA)
  ways   = 4
  sets   = 4096
  entry  = (V: 1 = 0, TAG: 15, DATA: 256)
  index  = pa.value<16..5>
  match  = V == 1 && TAG == pa.value<31..17>
  policy = PLRU

//==================================================================================================
// Main Memory
//==================================================================================================

// Corresponds to the "mem M" definition in the ISA specification.
buffer M (pa: PA)
  ways   = 1
  sets   = 1 << (32 - 5)
  entry  = (DATA: 256)
  index  = pa.value<31..5>
  match  = 0

//==================================================================================================
// MMU Logic (Interaction between L1 and L2)
//==================================================================================================

mmu pmem (va: VA) = (data: 32)
  var c: 3;

  var l1Entry: L1.entry;
  var l2Entry: L2.entry;

  var pa: PA;
  var cacheData: 256;
  var offset: 8;
  var bitOffset: 8;
  var x : 32;

  read = {
    trace ("E1=0x%x, E2=0x%x", E1, E2);
    trace ("C1=0x%x", C1);
    x = C1;

    // The default cache policy.
    c = 3;

    // Physical address is equal to virtual address.
    pa.value = va.value;

    offset<7..5> = 0;
    offset<4..0> = pa.value<4..0>;
    bitOffset = offset << 3;

    // The address is cacheable.
    if c<1..0> != 2 then
      // The address hits the L1.
      if L1(pa).hit then
        l1Entry = L1(pa);
        cacheData = l1Entry.DATA;
        data = cacheData<(bitOffset + 31)..bitOffset>;
      // The address does not hit the L1.
      else
        // The L2 cache is used.
        if c<1..0> == 3 then
          // The address hits the L2.
          if L2(pa).hit then
            l2Entry = L2(pa);
            cacheData = l2Entry.DATA;
            data = cacheData<(bitOffset + 31)..bitOffset>;

            // Fill the L1.
            l1Entry.V = 1;
            l1Entry.TAG = pa.value<31..12>;
            l1Entry.DATA = cacheData;
            L1(pa) = l1Entry;
          // The address does not hit the L2.
          else
            cacheData = M(pa);
            data = cacheData<(bitOffset + 31)..bitOffset>;

            // Fill L2.
            l2Entry.V = 1;
            l2Entry.TAG = pa.value<31..17>;
            l2Entry.DATA = cacheData;
            L2(pa) = l2Entry;

            // Fill L1.
            l1Entry.V = 1;
            l1Entry.TAG = pa.value<31..12>;
            l1Entry.DATA = cacheData;
            L1(pa) = l1Entry;
          endif; // If the address hits the L2.
        // The L2 cache is bypassed.
        else
          cacheData = M(pa);
          data = cacheData<(bitOffset + 31)..bitOffset>;

          l1Entry.V = 1;
          l1Entry.TAG = pa.value<31..12>;
          l1Entry.DATA = cacheData;
          L1(pa) = l1Entry;
        endif; // If the L2 cache is used.
      endif; // If the address hits the L1.
    // The address is uncacheable.
    else
      cacheData = M(pa);
      data = cacheData<(bitOffset + 31)..bitOffset>;
    endif; // If the address is cacheable.
  }

  write = {
    // The default cache policy.
    c = 3;

    // Physical address is equal to virtual address.
    pa.value = va.value;

    offset<7..5> = 0;
    offset<4..0> = pa.value<4..0>;
    bitOffset = offset << 3;

    // The address is cacheable.
    if c<1..0> != 2 then
      // The address hits the L1.
      if L1(pa).hit then
        // Update the L1.
        l1Entry = L1(pa);
        l1Entry.DATA<(bitOffset + 31)..bitOffset> = data;
        L1(pa) = l1Entry;

        // Only the write-through policy is supported.
        M(pa) = l1Entry.DATA;
      // The address does not hit the L1.
      else
        // The L2 cache is used.
        if c<1..0> == 3 then
          // The address hits the L2.
          if L2(pa).hit then
            // Update the L2.
            l2Entry = L2(pa);
            l2Entry.DATA<(bitOffset + 31)..bitOffset> = data;
            L2(pa) = l2Entry;

            // Fill the L1.
            l1Entry.V = 1;
            l1Entry.TAG = pa.value<31..12>;
            l1Entry.DATA = l2Entry.DATA;
            L1(pa) = l1Entry;

            // Only the write-through policy is supported.
            M(pa) = l1Entry.DATA;
          // The address does not hit the L2.
          else
            cacheData = M(pa);
            cacheData<(bitOffset + 31)..bitOffset> = data;
            M(pa) = cacheData;

            // Fill the L2.
            l2Entry.V = 1;
            l2Entry.TAG = pa.value<31..17>;
            l2Entry.DATA = cacheData;
            L2(pa) = l2Entry;

            // Fill the L1.
            l1Entry.V = 1;
            l1Entry.TAG = pa.value<31..12>;
            l1Entry.DATA = cacheData;
            L1(pa) = l1Entry;
          endif; // If the address hits the L2.
        // The L2 cache is bypassed.
        else
          cacheData = M(pa);
          cacheData<(bitOffset + 31)..bitOffset> = data;
          M(pa) = cacheData;

          // Fill the L2
          l1Entry.V = 1;
          l1Entry.TAG = pa.value<31..12>;
          l1Entry.DATA = cacheData;
          L1(pa) = l1Entry;
        endif; // If the L2 cache is used.
      endif; // If the address hits the L1.
    // The address is uncacheable.
    else
      cacheData = M(pa);
      cacheData<(bitOffset + 31)..bitOffset> = data;
      M(pa) = cacheData;
    endif; // If the address is cacheable.
  }

//==================================================================================================
// The End
//==================================================================================================

