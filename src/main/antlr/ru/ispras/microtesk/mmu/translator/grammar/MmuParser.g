/*
 * Copyright 2012-2020 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

parser grammar MmuParser;

//==================================================================================================
// Options
//==================================================================================================

options {
  language=Java;
  tokenVocab=MmuLexer;
  output=AST;
  superClass=ParserBase;
  backtrack=true;
}

import commonParser=CommonParser;

tokens {
  MMU_TU;
  MMU_CONTEXT;
  MMU_FUNC;
  MMU_FUNC_DEF;
}

//==================================================================================================
// Header for the Generated Java File
//==================================================================================================

@header {
/*
 * Copyright 2012-2020 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *
 * WARNING: THIS FILE IS AUTOMATICALLY GENERATED. PLEASE DO NOT MODIFY IT. 
 */

package ru.ispras.microtesk.mmu.translator.grammar;

import ru.ispras.microtesk.translator.antlrex.ParserBase;
import ru.ispras.microtesk.translator.nml.NmlSymbolKind;
import ru.ispras.microtesk.mmu.translator.MmuSymbolKind;
}

@members {
  boolean isInBitField() {
    return commonParser.isInBitField();
  }

  void setInBitField(boolean value) {
    commonParser.setInBitField(value);
  }
}

//==================================================================================================
// MMU Specification
//==================================================================================================

startRule 
    : declarationRev* EOF -> ^(MMU_TU declarationRev*)
    ;

declarationRev
    : rev=revision {
        pushRevisionApplicable($rev.applicable);
      }
      declaration {
        popRevisionApplicable();
      } -> {$rev.applicable}? declaration
        ->
    ;

declaration
    : let
    | extern
    | struct
    | address
    | function
    | operation
    | segment
    | buffer
    | mmu
    ;

//==================================================================================================
// Let
//==================================================================================================

let
    : MMU_LET^ id=ID ASSIGN! expr {
        declare($id, NmlSymbolKind.LET_CONST, false);
      }
    ;

//==================================================================================================
// Extern
//==================================================================================================

extern
    : MMU_EXTERN^ id=ID ASSIGN! externExpr {declare($id, MmuSymbolKind.EXTERN, false);}
    ;

externExpr
    : ID ((LEFT_HOOK! expr RIGHT_HOOK!) | (LEFT_PARENTH! (expr (COMMA! expr)*)? RIGHT_PARENTH!))?
    ;

//==================================================================================================
// Struct
//==================================================================================================

struct
    : MMU_STRUCT^ ID LEFT_PARENTH! fields RIGHT_PARENTH!
    ;

fields
    : field (COMMA! field)*
    ;

field
    : ID COLON! typeRef
    ;

typeRef
    : ID
    | expr (ASSIGN! expr)?
    ;

//==================================================================================================
// Address
//==================================================================================================

address
    : MMU_ADDRESS^ ID LEFT_PARENTH! addressType RIGHT_PARENTH! (COLON! addressValue)?
    ;

addressType
    : fields -> ^(MMU_STRUCT fields)
    | ID
    ;

addressValue
    : ID (DOT! ID)*
    ;

//==================================================================================================
// Function
//==================================================================================================

function
    : funcHeader funcBody -> ^(MMU_FUNC_DEF ^(MMU_FUNC funcHeader) funcBody)
    ;

funcHeader
    : functionDecl LEFT_PARENTH! funcParams? RIGHT_PARENTH! (COLON! mmuVariableType)?
    ;

funcParams
    : ID COLON mmuVariableType (COMMA ID COLON mmuVariableType)* ->
        ^(MMU_VAR ID mmuVariableType)+
    ;

funcBody
    : localVars LEFT_BRACE! sequence RIGHT_BRACE!
    ;

//==================================================================================================
// Operation
//==================================================================================================

operation
    : MMU_OP^ ID LEFT_PARENTH! ID COLON! ID RIGHT_PARENTH!
      mmuFunction
    ;

//==================================================================================================
// Segment
//==================================================================================================

segment
    : MMU_SEGMENT^ ID nameType ASSIGN! nameType
        range
        localVars
        (mmuFunction)?
    ;

nameType
    : LEFT_PARENTH! ID COLON! ID RIGHT_PARENTH!
    ;

range
    : MMU_RANGE^ ASSIGN! LEFT_PARENTH! expr COMMA! expr RIGHT_PARENTH!
    ;

//==================================================================================================
// Buffer
//==================================================================================================

buffer
    : kw=ID? bufferId (MMU_VIEWOF view=ID)? bufferParameterRev* ->
          ^(MMU_BUFFER bufferId ^(MMU_CONTEXT $kw?) $view? bufferParameterRev*)
    ;

bufferId
    : MMU_BUFFER! ID LEFT_PARENTH! ID COLON! ID RIGHT_PARENTH!
    ;

bufferParameterRev
    : rev=revision {
        pushRevisionApplicable($rev.applicable);
      }
      bufferParameter {
        popRevisionApplicable();
      } -> {$rev.applicable}? bufferParameter
        ->
    ;

bufferParameter
    : ways
    | sets
    | entry
    | index
    | match
    | policy
    | next
    ;

ways
    : MMU_WAYS^ ASSIGN! expr
    ;

sets
    : MMU_SETS^ ASSIGN! expr
    ;

entry
    : MMU_ENTRY^ ASSIGN! LEFT_PARENTH! fields RIGHT_PARENTH!
    ;

index
    : MMU_INDEX^ ASSIGN! expr
    ;

match
    : MMU_MATCH^ ASSIGN! expr
    ;

policy
    : MMU_POLICY^ ASSIGN! ID (VERT_BAR! ID)*
    ;

next
    : MMU_NEXT^ ASSIGN! ID
    ;

//==================================================================================================
// MMU Logic
//==================================================================================================

mmu
    : MMU^ ID LEFT_PARENTH! ID COLON! ID RIGHT_PARENTH! ASSIGN!
              LEFT_PARENTH! ID COLON! expr RIGHT_PARENTH!
        localVars
        (mmuFunction)*
    ;

localVars
    : (mmuVariable SEMI!)*
    ;

mmuVariable
    : MMU_VAR^ ID COLON! mmuVariableType
    ;

mmuVariableType
    : {!isDeclaredAs(input.LT(1), NmlSymbolKind.LET_CONST)}? ID (DOT MMU_ENTRY)? -> ID
    | expr
    ;

mmuFunction
    : ID ASSIGN! LEFT_BRACE! sequence RIGHT_BRACE!
    ;

//==================================================================================================
// The End
//==================================================================================================
