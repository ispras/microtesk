/*
 * Copyright 2018 ISP RAS (http://www.ispras.ru)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

group Whyml;

header(time) ::= <<
(*
 * Copyright (c) ISP RAS (http://www.ispras.ru)
 * All Rights Reserved
 *
 * Ivannikov Institute for System Programming of the Russian Academy of Sciences (ISP RAS)
 * 25 Alexander Solzhenitsyn st., Moscow, 109004, Russia
 * http://forge.ispras.ru/projects/microtesk
 *
 * The present file was generated by the MicroTESK tool on the basis of formal specifications.
 * It is distributed under the same terms and conditions as the derived specifications.
 * Generation started: <time>
 *
 * N.B. PLEASE DO NOT MODIFY THIS FILE.
 *)<\n>
>>

imports(names) ::= <<
<names:{n | use import <n>}; separator="\n"><\n>
>>

typedefs(types) ::= <<
<types:{t | type <t>}; separator="\n"><\n>
>>

variable_length_invariant(name, length) ::= <<
  invariant { Int32.to_int self.<name>.length = <length> }<\n>
>>

variable_length_invariants(names, lengths, arrays) ::= <<
<names, lengths, arrays:{n, l, is_a | <if(is_a)><variable_length_invariant(n, l)><endif>}>
>>

variable(name, type, is_array) ::= <<
<name> : <if(is_array)>Array32.array <endif><type>
>>

variables(names, types, arrays) ::= <<
<names, types, arrays:{n, t, is_a | <\n>    <variable(n, t, is_a)>}; separator="; ">
>>

state_file(time, name, imps, types, var_names, var_types, var_lengths, var_arrays) ::= <<
<header(time)>
module <name>
  <if(imps)><imports(imps)><endif>
  <if(types)><typedefs(types)><endif>
  type state model {<variables(var_names, var_types, var_arrays)><\n>  }
  <variable_length_invariants(var_names, var_lengths, var_arrays)>
end<\n>
>>

function(name, ret_type, arg_names, arg_types, expr) ::= <<
function <name> <arg_names, arg_types:{n, t| (<n> : <t>) }>: <ret_type> =
  <expr><\n>
>>

primitive_file(time, name, imps, funcs) ::= <<
<header(time)>
module <name>
  <if(imps)><imports(imps)><endif>
  <if(funcs)><funcs; separator="\n"><endif>
end<\n>
>>
