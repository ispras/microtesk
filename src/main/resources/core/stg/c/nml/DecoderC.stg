/*
 * Copyright 2016 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

group Decoder;

group_constructor(name, size, is_fixed, opc_mask, items) ::= <<
private <name>() {
  super(<size>, <is_fixed>, <opc_mask>);<\n>
  <items: {item | add(<item>.get());}; separator="\n">
}
>>

decoder_constructor(name, size, is_fixed, opc, opc_mask, stmts) ::= <<
private <name>() {
  super(
      <size>,
      <is_fixed>,
      <opc>,
      <opc_mask>
      );
}<\n>
public DecoderResult decode(final BitVector image) {
  if (!isOpcMatch(d, image)) {
    return null;
  }

  resetPosition(d);<\n>
  <stmts: {stmt | <stmt>}; separator="\n">
}
>>

decoder_result(name, args) ::= <<
<\n>return newResult(<name>(<args; separator=", ">));
>>

decoder_opc_check(value, size, name, count) ::= <<
char[] <name><count> = "<value>";
BIT_ARRAY* <name><count>_ba = bit_array_create(<size>);
bit_array_from_str(<name><count>_ba, <name><count>);
if (!matchNextOpc(d, image, <name><count>_ba)) {
  return NULL;
}
bit_array_free(<name><count>_ba);
>>

decoder_immediate(name, type) ::= <<
<name> = readNextImmediate(d, image, <type>);
>>

decoder_immediate_field(name, type, from, to) ::= <<
store(bitField(ACCESS(<name>), <from>, <to>), ACCESS(readNextImmediate(d, image, <type>)));
>>

decoder_temp_variable(name, type) ::= <<
store(ACCESS(<name>), ACCESS(readNextImmediate(d, image, <type>)));
>>

decoder_temp_variable_field(name, type, from, to) ::= <<
store(bitField(ACCESS(<name>), <from>, <to>), ACCESS(readNextImmediate(d, image, <type>)));
>>

decoder_primitive(name, type, decoder) ::= <<
<name> = (<type>) readNextPrimitive(d, image, <decoder>_get());
if (null == <name>) {
  return NULL;
}
>>

decoder_primitive_from_immediate(name, type, decoder) ::= <<
resetPosition(d);
<name> = (IsaPrimitive*) readNextPrimitive(d, load(ACCESS(<name>)).val, <decoder>_get());
if (NULL == <name>) {
  return NULL;
}
>>

decoder_build(name, file, size, is_fixed, opc, opc_mask, stmts, imps) ::= <<
<header(file)>
#include \<stdlib.h>
#include \<string.h>

DecoderResult <name>_decode(Decoder* d, BIT_ARRAY* image) {
  if (!isOpcMatch(d, image)) {
    return NULL;
  }

  resetPosition(d);<\n>
  <stmts: {stmt | <stmt>}; separator="\n">
}

Decoder* <name>() {
  Decoder* dec = (Decoder*) malloc(sizeof(Decoder));
  char[] opc_str = <opc>;
  char[] opc_mask_str = <opc_mask>;

  char* opc = (char*) malloc(sizeof(opc_str));
  char* opc_mask = (char*) malloc(sizeof(opc_mask_str));

  memcpy(opc, opc_str, sizeof(opc_str));
  memcpy(opc_mask, sizeof(opc_mask_str));

  dec->maxImageSize = <size>;
  dec->imageSizeFixed = <is_fixed>;
  dec->opcMask = opc_mask;
  dec->opc = opc;
  dec->position = 0;
  dec->decoderList = NULL;
  dec->decode = <name>_decode;

  return dec;
}<\n>

Decoder* <name>_get() {
  return <name>();
}

>>

group_build(name, size, is_fixed, opc_mask, items, members) ::= <<
<header(file)>
#include \<stdlib.h>
#include \<string.h>

private <name>() {
  Decoder* <name>() {
    Decoder* dec = (Decoder*) malloc(sizeof(Decoder));

    char[] opc_mask_str = <opc_mask>;
    char* opc_mask = (char*) malloc(sizeof(opc_mask_str));
    memcpy(opc_mask, sizeof(opc_mask_str));

    dec->maxImageSize = <size>;
    dec->imageSizeFixed = <is_fixed>;
    dec->opcMask = opc_mask;
    dec->opc = NULL;
    dec->position = 0;
    dec->decoderList = NULL;

    <items: {item | add(dec, <item>_get());}; separator="\n">

    return dec;
  }<\n>
}

Decoder* <name>_get() {
  return <name>();
}

>>
