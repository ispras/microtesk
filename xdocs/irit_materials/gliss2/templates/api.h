/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */
#ifndef GLISS_$(PROC)_INCLUDE_$(PROC)_API_H
#define GLISS_$(PROC)_INCLUDE_$(PROC)_API_H

#include <stdint.h>
#include <stdio.h>

#if defined(__WIN32) || defined(__WIN64)
#	ifdef __cplusplus
#		define __BEGIN_DECLS	extern "C" {
#		define __END_DECLS		}
#	else
#		define __BEGIN_DECLS
#		define __END_DECLS
#	endif
#else
#	include <sys/cdefs.h>
#endif


#include "id.h"
#include "mem.h"
#include "decode.h"

#define $(PROC)_PROC_NAME "$(PROC)"
#define $(PROC)_PC_NAME  $(pc_name)

/* return an instruction identifier as a string instead of the $(proc)_ident_t which is not very user friendly */
char *$(proc)_get_string_ident($(proc)_ident_t id);

/* opaque types */
typedef struct $(proc)_platform_t $(proc)_platform_t;
typedef struct $(proc)_fetch_t $(proc)_fetch_t;
typedef struct $(proc)_decoder_t $(proc)_decoder_t;
struct $(proc)_loader_t;
$(if is_CISC_present)typedef struct mask_t mask_t;
$(end)

/* $(proc)_state_t type */
typedef struct $(proc)_state_t {
	$(proc)_platform_t *platform;
$(foreach registers)$(if !aliased)$(if array)
	$(type) $(name)[$(size)];
$(else)
	$(type) $(name);
$(end)$(end)$(end)
$(foreach memories)$(if !aliased)
	$(proc)_memory_t *$(NAME);
$(end)$(end)
} $(proc)_state_t;

/* $(proc)_sim_t type */
typedef struct $(proc)_sim_t {
	$(proc)_state_t *state;
	$(proc)_decoder_t *decoder;
	/* on libc stripped programs it is difficult to find the exit point, so we specify it */
	$(proc)_address_t addr_exit;
	/* anything else? */
	int ended;
} $(proc)_sim_t;


$(if !GLISS_INSTR_FAST_STRUCT)
/* $(proc)_value_t type */
typedef union $(proc)_value_t {
$(foreach values)
	$(type) $(name);
$(end)
} $(proc)_value_t;
$(end)


$(if !GLISS_INSTR_FAST_STRUCT)
/* $(proc)_ii_t type */
typedef struct $(proc)_ii_t {
	$(proc)_value_t val;
} $(proc)_ii_t;
$(end)

/* $(proc)_inst_t type */
typedef struct $(proc)_inst_t {
	$(proc)_ident_t   ident;
	$(proc)_address_t addr;
$(if !GLISS_INSTR_FAST_STRUCT)
	$(proc)_ii_t instrinput[$(max_operand_nb)];
$(else)
	union {
		$(foreach instructions)struct {
			$(foreach params)$(TYPE) $(PARAM);
			$(end)
		} op_struct_$(ident);
		$(end)
	} op_union;
$(end)

} $(proc)_inst_t;

/* auxiliary vector */
typedef struct $(proc)_auxv_t {
	int	a_type;
	union {
		long a_val;
		void *a_ptr;
		void (*a_fcn)();
	} a_un;
} $(proc)_auxv_t;

/* environment description */
typedef struct $(proc)_env_t
{
	int argc;

	char **argv;
	$(proc)_address_t argv_addr;

	char **envp;
	$(proc)_address_t envp_addr;

	$(proc)_auxv_t *auxv;
	$(proc)_address_t auxv_addr;

	$(proc)_address_t stack_pointer;
	$(proc)_address_t brk_addr;
} $(proc)_env_t;

/* platform management */
#define $(PROC)_MAIN_MEMORY		0
$(proc)_platform_t *$(proc)_new_platform(void);
$(proc)_memory_t *$(proc)_get_memory($(proc)_platform_t *platform, int index);
struct $(proc)_env_t;
struct $(proc)_env_t *$(proc)_get_sys_env($(proc)_platform_t *platform);
void $(proc)_lock_platform($(proc)_platform_t *platform);
void $(proc)_unlock_platform($(proc)_platform_t *platform);
int $(proc)_load_platform($(proc)_platform_t *platform, const char *path);
void $(proc)_load($(proc)_platform_t *platform, struct $(proc)_loader_t *loader);

/* fetching */
$(proc)_fetch_t *$(proc)_new_fetch($(proc)_platform_t *pf$(if is_multi_set), $(proc)_state_t *state$(end));
void $(proc)_delete_fetch($(proc)_fetch_t *fetch);

$(if is_multi_set)
typedef union {
$(foreach instr_sets_sizes)
	$(if is_RISC_size)uint$(C_size)_t u$(C_size)$(else)mask_t *mask$(end);
$(end)} code_t;$(end)

$(proc)_ident_t $(proc)_fetch($(proc)_fetch_t *fetch, $(proc)_address_t address, $(code_write_param_decl)code);

/* decoding */
$(proc)_decoder_t *$(proc)_new_decoder($(proc)_platform_t *pf);
void $(proc)_delete_decoder($(proc)_decoder_t *decoder);
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address);
void $(proc)_free_inst($(proc)_inst_t *inst);
$(if is_multi_set)/* only used if several ISS defined to fully initialize decoder structure,
 * does nothing if one inst set only is defined */
void $(proc)_set_cond_state($(proc)_decoder_t *decoder, $(proc)_state_t *state);
/* decoding functions for one specific instr set */
$(foreach instruction_sets)/* decoding function for instr set $(idx), named $(iset_name) */
$(proc)_inst_t *$(proc)_decode_$(iset_name)($(proc)_decoder_t *decoder, $(proc)_address_t address);
$(end)$(end)
unsigned long $(proc)_get_inst_size($(proc)_inst_t* inst);
unsigned long $(proc)_get_inst_size_from_id($(proc)_ident_t id);


/* code execution */
void $(proc)_execute($(proc)_state_t *state, $(proc)_inst_t *inst);

/* state management function */
$(proc)_state_t *$(proc)_new_state($(proc)_platform_t *platform);
void $(proc)_delete_state($(proc)_state_t *state);
$(proc)_state_t *$(proc)_copy_state($(proc)_state_t *state);
$(proc)_state_t *$(proc)_fork_state($(proc)_state_t *state);
void $(proc)_dump_state($(proc)_state_t *state, FILE *out);
$(proc)_platform_t *$(proc)_platform($(proc)_state_t *state);

/* simulation functions */
$(proc)_sim_t *$(proc)_new_sim($(proc)_state_t *state, $(proc)_address_t start_addr, $(proc)_address_t exit_addr);
$(proc)_inst_t *$(proc)_next_inst($(proc)_sim_t *sim);
uint64_t $(proc)_run_and_count_inst($(proc)_sim_t *sim);
void $(proc)_run_sim($(proc)_sim_t *sim);
void $(proc)_step($(proc)_sim_t *sim);
void $(proc)_delete_sim($(proc)_sim_t *sim);
$(proc)_address_t  $(proc)_next_addr($(proc)_sim_t *sim);
void $(proc)_set_next_address($(proc)_sim_t *sim, $(proc)_address_t address);
#define $(proc)_set_entry_address(sim, addr) $(proc)_set_next_address(sim, addr)
void $(proc)_set_exit_address($(proc)_sim_t *sim, $(proc)_address_t address);
#define $(proc)_set_sim_ended(sim) (sim)->ended = 1
#define $(proc)_is_sim_ended(sim) ((sim)->ended)

/* disassemble function */
void $(proc)_disasm(char *buffer, $(proc)_inst_t *inst);

$(if is_CISC_present)
/* variable length functions */
uint32_t value_on_mask(mask_t *inst, mask_t *mask);
$(end)

#endif /* GLISS_$(PROC)_INCLUDE_$(PROC)_API_H */
