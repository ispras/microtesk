====== Modules ======

The library generated by @(GLISS) is made of a set of module.
Each module must fulfill a specific interface which makes easy to
replace a module by another one while both implements the same
interface.

===== Command Line =====

The matching between interface and their implementing modules is
passed at generation time by the ''-m'' option to the GEP command.
The ''-m'' argument is composed of two part separated by '':'',
//interface//://module//. The first part is the interface name
and the second part is the implementing module, possibly a path
to the module implementation file.

During the source generation, module implementation file are looked
in different directories:
  * ./ -- to get modules from the current implementation
  * GLISS_PREFIX/lib -- to get standard modules provided by @(GLISS)

The modules implementation files must be named //module//**.c** and
//module//**.h**. They are copied to the source directory and
renamed, respectively, //interface//**.c** and //interface//**.h**.
The goal is that any module may be replaced by any implementation
without modification in the user module.

Modules may also provide a file called //module//.info that will contain
details about the module compilation. This file is a text containing
a definition, in each line, of the form //VARIABLE//**=**//definition//.
The supported //VARIABLE// are:
  * ''CFLAGS'' -- options to pass to the C compiler for module compilation
  * ''CODE_HEADER'' -- source to add in the header of ''code_table.h''
  * ''LIBADD'' -- options to pass to compile a @(GLISS) library user


===== Standard Symbols =====

The modules must implements an interface but also a set of standard
module symbols in the file //module//**.h**.
  * **GLISS_**//interface//**_STATE** -- type of the module data (included in the ''platform_t'')
  * **GLISS_**//interface//**_INIT(p)** -- called when the platform //p// is created (to initialize module data)
  * **GLISS_**//interface//**_DESTROY(p)** -- called when the platform //p// is destroyed (to release module data)

This modules may be defined as types or functions or as macros.
For example, if a module implemeting the interface ''MINE'' does not use any data in the platform,
the following definition will hold:
<code c>
#define GLISS_MINE_STATE
#define GLISS_MINE_INIT(p)
#define GLISS_MINE_DESTROY(p)
</code>



===== ''error'' interface =====

This module is responsible to handle errors.

Implementing modules: ''error''.

==== Functions ====
<code c>
void gliss_panic(const char *format, ...);
</code>

Function called when the simulator is about to crash.
The argument are the same as passed to ''printf''. This function
must never return.

<code c>
void gliss_error(gliss_state_t *state, gliss_inst_t *inst, const char *format, ...);
</code>

Function called when an error arise. The two last argument are the same
as a printf and gives details about the error. The ''state'' is the current
state and the ''inst'' is the instruction causing the error.


===== ''mem'' interface =====

This module provides features to emulate the simulator memory.
This module is also responsible of the byte order management if the host
machine and the simulated machine have different endianness.
@(GLISS) provides two constant to this end:
  * TARGET_ENDIANNESS -- simulated machine endianness
  * HOST_ENDIANNESS -- host machine endianness

Their value may be 0 for little endian, 1 for big endian.

Implementing modules: 
  * ''fast_mem'' -- standard memory module with a two-levels depth hashtable.
  * ''vfast_mem'' --  faster module with a one level hashtable, and a better endianness handling (it does not byte swap memory at each memory acces when endianness differs from NML to host machine),
should be used as default module for standard simulation.
  * ''mem16'' -- fast module for 16 bit addressed memory, data are stored directly in a 2^16 bytes array.
  * ''io_mem'' -- modified ''fast_mem'' module useful to simulate memory mapped peripherics or other exotic memory accesses. A callback function can be specified for each page, when accessing a page, if a callback fucntion is present,
it is called with informations about the address, size, type (read/write) and data (if written) of the access. This function will provide the real read data or simulate the writing regarding of the access type.


==== Types ====
<code c>
typedef uint32_t gliss_address_t;
</code>
This type is used to represent addresses.

<code c>
typedef struct gliss_memory_t gliss_memory_t;
</code>
This type represents the memory.


=== Types for ''io_mem'' only ===

<code c>
#define GLISS_MEM_READ  0
#define GLISS_MEM_WRITE 1
</code>
Type access values to specify to the callback function.

<code c>
typedef void (*gliss_callback_fun_t)(gliss_address_t addr, int size, void *data, int type_access);
</code>
Callback function prototype.

==== Functions ====
<code c>
gliss_memory_t *gliss_mem_new(void);
</code>
Build and return a new memory.

<code c>
void gliss_mem_delete(gliss_memory_t *memory);
</code>
Release an existing memory.

<code c>
gliss_memory_t *gliss_mem_copy(gliss_memory_t *memory);
</code>
Build a copy of an existing memory.

<code c>
uint8_t gliss_mem_read8(gliss_memory_t *, gliss_address_t);
</code>
Read an 8-bits value from the memory at the given address.

<code c>
uint16_t gliss_mem_read16(gliss_memory_t *, gliss_address_t);
</code>
Read a 16-bits value from the memory at the given address.

<code c>
uint32_t gliss_mem_read32(gliss_memory_t *, gliss_address_t);
</code>
Read a 32-bits value from the memory at the given address.

<code c>
uint64_t gliss_mem_read64(gliss_memory_t *, gliss_address_t);
</code>
Read a 64-bits value from the memory at the given address.

<code c>
float gliss_mem_readf(gliss_memory_t *, gliss_address_t);
</code>
Read a float value from the memory at the given address.

<code c>
double gliss_mem_readd(gliss_memory_t *, gliss_address_t);
</code>
Read a double value from the memory at the given address.

<code c>
long double gliss_mem_readld(gliss_memory_t *, gliss_address_t);
</code>
Read a long double value from the memory at the given address.

<code c>
void gliss_mem_read(gliss_memory_t *memory, gliss_address_t, void *buf, size_t size);
</code>
Read a block of the given size from memory and store in the given buffer.

<code c>
void gliss_mem_write8(gliss_memory_t *, gliss_address_t, uint8_t);
</code>
Write an 8-bits value in memory at the given address.

<code c>
void gliss_mem_write16(gliss_memory_t *, gliss_address_t, uint16_t);
</code>
Write a 16-bits value in memory at the given address.

<code c>
void gliss_mem_write32(gliss_memory_t *, gliss_address_t, uint32_t);
</code>
Write a 32-bits value in memory at the given address.

<code c>
void gliss_mem_write64(gliss_memory_t *, gliss_address_t, uint64_t);
</code>
Write a 64-bits value in memory at the given address.

<code c>
void gliss_mem_writef(gliss_memory_t *, gliss_address_t, float);
</code>
Write a float value in memory at the given address.

<code c>
void gliss_mem_writed(gliss_memory_t *, gliss_address_t, double);
</code>
Write a double value in memory at the given address.

<code c>
void gliss_mem_writeld(gliss_memory_t *, gliss_address_t, long double);
</code>
Write a long double value in memory at the given address.

<code c>
void gliss_mem_write(gliss_memory_t *memory, gliss_address_t, void *buf, size_t size);
</code>
Write a block of memory of the given size from the given buffer in
the memory at the given address.


=== ''io_mem'' callback related functions ===

<code c>
void gliss_set_range_callback(gliss_memory_t *mem, gliss_address_t start, gliss_address_t end, gliss_callback_fun_t f);
</code>
Sets a callback function for the smallest set of pages covering the given memory range, replace the former callback function if present.

<code c>
void gliss_unset_range_callback(gliss_memory_t *mem, gliss_address_t start, gliss_address_t end);
</code>
Removes the callback function for the smallest set of pages covering the given memory range, do nothing if no callback fucntion is present.


===== ''fetch'' interface =====

This module implements the fetch phase, that is, find the instruction
identifier from the instruction address. Usually, the fetch phase
usually includes the fetch table found in ''fetch_table.h''.

Implementing modules:
  * ''fetch'' -- implements specialized fetch for RISC architectures or a generic fetch for CISC architectures,
this module will be produced by default by GEP even if you do not specify it on command line.

==== Types ====

<code c>
struct gliss_fetch_t { ... };
</code>

Type of the fetch handler, that is, the data structure containing
information for fetching.

==== Functions ====

<code c>
int gliss_fetch(gliss_fetch_t *fetch, gliss_address_t address);
</code>
Compute the identifier of the instruction at the given address.

<code c>
gliss_fetch_t *gliss_new_fetch(gliss_platform_t *platform);
</code>
Build a new fetch handler working on the given platform.

<code c>
void gliss_delete_fetch(gliss_fetch_t *fetch);
</code>
Delete a fetch handler.



===== ''decode'' interface =====

Implements the decoder phase, that is, the phase that decode arguments
of an instruction and generates a ''gliss_inst_t *'' object.
The decoder table are provided by GEP in the file ''decode_table.h''.

Implementing modules:
  * ''decode'' -- implements specialized decoder for RISC architectures or a generic decoder for CISC architectures,
this module will be produced by default by GEP if you do not specify any decode module on command line.

==== Types ====

<code c>
struct gliss_decoder_t { ... };
</code>
Handler type for decoding.

==== Functions ====

<code c>
gliss_inst_t *gliss_decode(gliss_decoder_t *decoder, gliss_address_t address);
</code>
Decode the instruction at the given address.

<code c>
void gliss_free_inst(gliss_inst_t *inst);
</code>
Free a previously allocated instruction by ''gliss_decode''.

<code c>
gliss_decoder_t *gliss_new_decoder(gliss_platform_t *platform);
</code>
Build a new decoder handler from the given platform.

<code c>
void gliss_delete_decoder(gliss_decoder_t *decode);
</code>
Delete a decoder handler.

==== Multi instruction set decode related functions ====

Functions which can be used if several instruction sets are defined in the same description.

<code c>
void gliss_set_cond_state(gliss_decoder_t *decoder, gliss_state_t *state);
</code>
A condition (expression based on state registers, given in NMP sources) is calculated to choose which instruction set a decoder will decode for,
so you need to give the decoder a state whose registers will be used to know which decoding will be chosen.

<code c>
gliss_inst_t *gliss_decode_<ISET_NAME>(gliss_decoder_t *decoder, gliss_address_t address);
</code>
Force decoding for one given instruction set (<ISET_NAME> being the instruction set name given in NMP sources),
one function is automatically generated for each instruction set defined in NMP sources.

===== ''code'' module =====

This module implements the execution of an instruction. The code table
are provided by GEP in the file ''code_table.h''.

Implementation modules:
  * ''code'' -- default execution module

==== Functions ====

<code c>
void gliss_execute(gliss_state_t *state, gliss_inst_t *inst);
</code>
Execute the given instruction in the given state.





===== ''loader'' module =====

Implements the loader used by the simulator.

Implementing modules:
  * ''old_elf'' -- loader for ELF file

==== Types ====

<code c>
struct gliss_loader_t { ... };
</code>
Type of loader handler.

<code c>
typedef struct {
	const char *name;
	gliss_address_t value;
	int size;
	int sect;
	enum {
		GLISS_LOADER_SYM_NO_TYPE,
		GLISS_LOADER_SYM_DATA,
		GLISS_LOADER_SYM_CODE
	} type;
	enum {
		GLISS_LOADER_NO_BINDING,
		GLISS_LOADER_LOCAL,
		GLISS_LOADER_GLOBAL,
		GLISS_LOADER_WEAK
	} bind;
} gliss_loader_sym_t;
</code>
Type of symbols defined in the loaded file.

<code c>
typedef struct gliss_loader_sect_t {
	const char *name;
	gliss_address_t addr;
	int size;
	enum {
		GLISS_LOADER_SECT_UNKNOWN = 0,
		GLISS_LOADER_SECT_TEXT,
		GLISS_LOADER_SECT_DATA,
		GLISS_LOADER_SECT_BSS
	} type;
} gliss_loader_sect_t;
</code>
Type of the section of the file.


==== Functions ====

<code c>
gliss_loader_t *gliss_loader_open(const char *path);
</code>
Open a file with the given path. Return NULL if the file can not be
opened (IO error or bad format).

<code c>
void gliss_loader_close(gliss_loader_t *loader);
</code>
Release a loader handler.

<code c>
void gliss_loader_load(gliss_loader_t *loader, gliss_platform_t *pf);
</code>
Load the content of the file in the given platform, that is, copies
code and data sections in the platform memories.

<code c>
gliss_address_t gliss_loader_start(gliss_loader_t *loader);
</code>
Find the start address for the program execution.

<code c>
gliss_address_t gliss_brk_init(gliss_loader_t *loader);
</code>
Get the start address of the BRK point, that is, the start address
for performing allocation. Usually, this is the top address of the
last section.

<code c>
int gliss_loader_count_sects(gliss_loader_t *loader);
</code>
Get the count of sections.

<code c>
void gliss_loader_sect(gliss_loader_t *loader, int sect, gliss_loader_sect_t *data);
</code>
Get the information in the provided section data for the numbered section.
The section number be between 0 and ''gliss_loader_count_sects()'' - 1.

<code c>
int gliss_loader_count_syms(gliss_loader_t *loader);
</code>
Get the symbol count.

<code c>
void gliss_loader_sym(gliss_loader_t *loader, int sym, gliss_loader_sym_t *data);
</code>
Get the symbol information for the numbered symbol. This number must be
between 0 and ''gliss_loader_count_syms()''.



===== ''syscall'' interface =====

Module implementing the system calls.

Implementing modules:
  * ''syscall-linux'' -- Linux system calls.

==== Function ====

<code c>
void gliss_syscall(gliss_inst_t *inst, gliss_state_t *state);
</code>
Perform the system call.

<code c>
void gliss_set_brk(gliss_platform_t *pf, gliss_address_t address);
</code>
Inform the system about the top address of the program. With POSIX
compliant system, this is used to implement the ''brk'' system call.



===== ''sysparm'' interface =====

Module implementing the parameter access during a system call.

Implementing modules:
  * ''sysparm-reg32'' -- parameter for a 32-bits system.

==== Types ====

<code c>
typedef ... gliss_sysparm_t;
</code>
Parameter handler for accessing parameter of a system call.

==== Functions ====

<code c>
#define gliss_sysparm_init(parm, state) ...
</code>
Initialize the parameter access for the given state.

<code c>
#define gliss_sysparm_destroy(parm, state) ...
</code>
Destroy the paramater access handler.

<code c>
#define gliss_sysparm_pop8(parm, state) ...
</code>
Access a 8-bits parameter.

<code c>
#define gliss_sysparm_pop16(parm, state) ...
</code>
Access a 16-bits parameter.

<code c>
#define gliss_sysparm_pop32(parm, state) ...
</code>
Access a 32-bits parameter.

<code c>
#define gliss_sysparm_return(state, result) ...
</code>
Return a result.

<code c>
#define gliss_sysparm_succeed(state) ...
</code>
Inform the system call has succeeded.

<code c>
#define gliss_sysparm_failed(state) ...
</code>
Inform that the system call has failed.



===== ''env'' interface =====

Module preparing the initial stack of the program.

Implementing modules:
  * ''void_env'' -- no stack is built.
  * ''linux_env'' -- for PowerPC linux stack initialization.

==== Functions ====

<code c>
void gliss_stack_fill_env(gliss_loader_t *loader, gliss_platform_t *platform,  gliss_env_t *env);
</code>
Initialize the stack.

<code c>
void gliss_registers_fill_env(gliss_env_t *env, gliss_state_t *state);
</code>
Initialize the register according to the stack.

===== ''debug'' interface =====

This module provides information to do a debugger and, mainly, the description
of used registers and functions to read or write these registers.

Implementing modules:
  * ''debug'' -- the currently unique implementation.

==== Types ====

<code>
typedef enum {
	RTYPE_NONE = 0,
	RTYPE_BITS,
	RTYPE_ADDR,
	RTYPE_INT,
	RTYPE_FLOAT
} register_type_t;

typedef struct register_bank_t {
	int id;
	const char *name;
	const char *format;
	int size;
	register_type_t type;
	int tsize;
	union {
		register_field_t fields;
	} data;
} register_bank_t;
</code>

The ''register_bank_t'' structure is used to describe a register bank.
It is made of:
  ? ''id'' : identifier of the bank used by other primitives,
  ? ''name'' : name of the bank to display to the user,
  ? ''format'' : format to derive indexed register (it contains a ''%d'' to replace by the register number),
  ? ''size'' : number of registers in the bank,
  ? ''type'' : a type among ''RTYPE_''//XXX// constant (it is just a hint),
  ? ''tsize'' : size in its of the registers in the bank,
  ? ''data'' : not used at this time.

<code>
typedef union {
	int32_t iv;
	int64_t lv;
	float fv;
	double dv;
} register_value_t;
</code>

This union type allows to exchange values between the program and the //debug// API.
According to the type of the register in the bank, one of the union field will be used.

==== Functions ====

<code>
register_bank_t *gliss_get_registers(void);
</code>
Get the array of register banks whose last element is a bank whose ''id'' is -1.

<code>
register_value_t gliss_get_register(gliss_state_t *state, int id, int index);
</code>
Get the value of a register in the given state, identified by ''id'' and, if the bank is indexed,
using the given index.

<code>
void gliss_set_register(gliss_state_t *state, int id, int index, register_value_t value);
</code>
Change the value of register in the given state. It is identifier by the ''id'', possibly indexed,
and the value is used to change the register.

